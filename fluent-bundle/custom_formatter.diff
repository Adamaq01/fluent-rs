diff --git a/fluent-bundle/examples/functions.rs b/fluent-bundle/examples/functions.rs
index 36fb918..00f2de2 100644
--- a/fluent-bundle/examples/functions.rs
+++ b/fluent-bundle/examples/functions.rs
@@ -25,7 +25,7 @@ fn main() {
     bundle
         .add_function("MEANING_OF_LIFE", |args, _named_args| {
             if let Some(arg0) = args.get(0) {
-                if *arg0 == FluentValue::Number("42".into()) {
+                if *arg0 == FluentValue::into_number("42") {
                     return "The answer to life, the universe, and everything".into();
                 }
             }
diff --git a/fluent-bundle/src/bundle.rs b/fluent-bundle/src/bundle.rs
index af63b85..4deb878 100644
--- a/fluent-bundle/src/bundle.rs
+++ b/fluent-bundle/src/bundle.rs
@@ -130,6 +130,7 @@ pub struct FluentBundle<R> {
     pub(crate) intls: RefCell<IntlLangMemoizer>,
     pub(crate) use_isolating: bool,
     pub(crate) transform: Option<Box<dyn Fn(&str) -> Cow<str> + Send + Sync>>,
+    pub(crate) formatter: Option<Box<dyn Fn(&FluentValue) -> Option<String> + Send + Sync>>,
 }
 
 impl<R> FluentBundle<R> {
@@ -169,6 +170,7 @@ impl<R> FluentBundle<R> {
             intls: RefCell::new(IntlLangMemoizer::new(lang)),
             use_isolating: true,
             transform: None,
+            formatter: None,
         }
     }
 
@@ -385,6 +387,17 @@ impl<R> FluentBundle<R> {
         }
     }
 
+    pub fn set_formatter<F>(&mut self, func: Option<F>)
+    where
+        F: Fn(&FluentValue) -> Option<String> + Send + Sync + 'static,
+    {
+        if let Some(f) = func {
+            self.formatter = Some(Box::new(f));
+        } else {
+            self.formatter = None;
+        }
+    }
+
     /// Returns true if this bundle contains a message with the given id.
     ///
     /// # Examples
@@ -438,7 +451,7 @@ impl<R> FluentBundle<R> {
         R: Borrow<FluentResource>,
     {
         let mut scope = Scope::new(self, args);
-        let result = pattern.resolve(&mut scope).as_string();
+        let result = pattern.resolve(&mut scope).as_string(Some(&scope));
 
         for err in scope.errors {
             errors.push(err.into());
@@ -470,7 +483,7 @@ impl<R> FluentBundle<R> {
     ///
     /// // Register a fn that maps from string to string length
     /// bundle.add_function("STRLEN", |positional, _named| match positional {
-    ///     [FluentValue::String(str)] => FluentValue::Number(str.len().to_string().into()),
+    ///     [FluentValue::String(str)] => FluentValue::Number(str.len() as f64, None),
     ///     _ => FluentValue::None,
     /// }).expect("Failed to add a function to the bundle.");
     ///
@@ -509,6 +522,7 @@ impl<R> Default for FluentBundle<R> {
             use_isolating: true,
             intls: RefCell::new(IntlLangMemoizer::new(langid)),
             transform: None,
+            formatter: None,
         }
     }
 }
diff --git a/fluent-bundle/src/resolve.rs b/fluent-bundle/src/resolve.rs
index a3b27ee..da503a5 100644
--- a/fluent-bundle/src/resolve.rs
+++ b/fluent-bundle/src/resolve.rs
@@ -180,7 +180,7 @@ impl<'source> ResolveValue<'source> for ast::Pattern<'source> {
                     }
 
                     let result = scope.maybe_track(self, p);
-                    write!(string, "{}", result).expect("Writing failed");
+                    write!(string, "{}", result.as_string(Some(scope))).expect("Writing failed");
 
                     if needs_isolation {
                         string.write_char('\u{2069}').expect("Writing failed");
@@ -202,7 +202,7 @@ impl<'source> ResolveValue<'source> for ast::Expression<'source> {
             ast::Expression::SelectExpression { selector, variants } => {
                 let selector = selector.resolve(scope);
                 match selector {
-                    FluentValue::String(_) | FluentValue::Number(_) => {
+                    FluentValue::String(_) | FluentValue::Number(_, _) => {
                         for variant in variants {
                             let key = match variant.key {
                                 ast::VariantKey::Identifier { name } => {
diff --git a/fluent-bundle/src/types.rs b/fluent-bundle/src/types.rs
index dca91d1..3031d97 100644
--- a/fluent-bundle/src/types.rs
+++ b/fluent-bundle/src/types.rs
@@ -165,7 +165,7 @@ impl<T: Any + PartialEq> AnyEq for T {
 #[derive(Debug)]
 pub enum FluentValue<'source> {
     String(Cow<'source, str>),
-    Number(Cow<'source, str>),
+    Number(f64, Option<usize>),
     Custom(Box<dyn FluentType>),
     Error(DisplayableNode<'source>),
     None,
@@ -175,7 +175,7 @@ impl<'s> PartialEq for FluentValue<'s> {
     fn eq(&self, other: &Self) -> bool {
         match (self, other) {
             (FluentValue::String(s), FluentValue::String(s2)) => s == s2,
-            (FluentValue::Number(s), FluentValue::Number(s2)) => s == s2,
+            (FluentValue::Number(s, _), FluentValue::Number(s2, _)) => s == s2,
             (FluentValue::Custom(s), FluentValue::Custom(s2)) => s == s2,
             _ => false,
         }
@@ -186,7 +186,7 @@ impl<'s> Clone for FluentValue<'s> {
     fn clone(&self) -> Self {
         match self {
             FluentValue::String(s) => FluentValue::String(s.clone()),
-            FluentValue::Number(s) => FluentValue::Number(s.clone()),
+            FluentValue::Number(s, o) => FluentValue::Number(s.clone(), o.clone()),
             FluentValue::Custom(s) => {
                 let new_value: Box<dyn FluentType> = s.duplicate();
                 FluentValue::Custom(new_value)
@@ -200,7 +200,14 @@ impl<'source> FluentValue<'source> {
     pub fn into_number<S: ToString>(v: S) -> Self {
         let s = v.to_string();
         match f64::from_str(&s) {
-            Ok(_) => FluentValue::Number(s.into()),
+            Ok(n) => {
+                if let Some(pos) = s.find('.') {
+                    let frac = s.len() - pos - 1;
+                    FluentValue::Number(n, Some(frac))
+                } else {
+                    FluentValue::Number(n, None)
+                }
+            }
             Err(_) => FluentValue::String(s.into()),
         }
     }
@@ -212,8 +219,10 @@ impl<'source> FluentValue<'source> {
     ) -> bool {
         match (self, other) {
             (&FluentValue::String(ref a), &FluentValue::String(ref b)) => a == b,
-            (&FluentValue::Number(ref a), &FluentValue::Number(ref b)) => a == b,
-            (&FluentValue::String(ref a), &FluentValue::Number(ref b)) => {
+            (&FluentValue::Number(ref a, ref o1), &FluentValue::Number(ref b, ref o2)) => {
+                a == b && o1 == o2
+            }
+            (&FluentValue::String(ref a), num @ &FluentValue::Number(..)) => {
                 let cat = match a.as_ref() {
                     "zero" => PluralCategory::ZERO,
                     "one" => PluralCategory::ONE,
@@ -227,16 +236,29 @@ impl<'source> FluentValue<'source> {
                 let pr = intls_borrow
                     .try_get::<PluralRules>((PluralRuleType::CARDINAL,))
                     .expect("Failed to retrieve plural rules");
-                pr.0.select(b.as_ref()) == Ok(cat)
+                let formatted_number = num.as_string(Some(&scope));
+                pr.0.select(formatted_number.to_string()) == Ok(cat)
             }
             _ => false,
         }
     }
 
-    pub fn as_string(&self) -> Cow<'source, str> {
+    pub fn as_string<R: Borrow<FluentResource>>(
+        &self,
+        scope: Option<&Scope<R>>,
+    ) -> Cow<'source, str> {
+        if let Some(ref scope) = scope {
+            if let Some(ref fmt) = scope.bundle.formatter {
+                if let Some(val) = fmt(self) {
+                    return val.into();
+                }
+            }
+        }
         match self {
             FluentValue::String(s) => s.clone(),
-            FluentValue::Number(n) => n.clone(),
+            FluentValue::Number(n, _) => {
+                return n.to_string().into();
+            }
             FluentValue::Error(d) => format!("{{{}}}", d.to_string()).into(),
             FluentValue::Custom(s) => s.as_string(),
             FluentValue::None => "???".into(),
@@ -244,18 +266,6 @@ impl<'source> FluentValue<'source> {
     }
 }
 
-impl<'source> fmt::Display for FluentValue<'source> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            FluentValue::String(s) => f.write_str(s),
-            FluentValue::Number(n) => f.write_str(n),
-            FluentValue::Error(d) => write!(f, "{{{}}}", d),
-            FluentValue::Custom(s) => s.fmt(f),
-            FluentValue::None => f.write_str("???"),
-        }
-    }
-}
-
 impl<'source> From<String> for FluentValue<'source> {
     fn from(s: String) -> Self {
         FluentValue::String(s.into())
@@ -272,12 +282,12 @@ macro_rules! from_num {
     ($num:ty) => {
         impl<'source> From<$num> for FluentValue<'source> {
             fn from(n: $num) -> Self {
-                FluentValue::Number(n.to_string().into())
+                FluentValue::into_number(n)
             }
         }
         impl<'source> From<&'source $num> for FluentValue<'source> {
             fn from(n: &'source $num) -> Self {
-                FluentValue::Number(n.to_string().into())
+                FluentValue::into_number(n)
             }
         }
     };
@@ -306,6 +316,6 @@ mod tests {
         let x = 1i16;
         let y = &x;
         let z: FluentValue = y.into();
-        assert_eq!(z, FluentValue::Number("1".into()));
+        assert_eq!(z, FluentValue::into_number("1"));
     }
 }
diff --git a/fluent-bundle/tests/fixtures/arguments.yaml b/fluent-bundle/tests/fixtures/arguments.yaml
index 6ffa267..a10f5ea 100644
--- a/fluent-bundle/tests/fixtures/arguments.yaml
+++ b/fluent-bundle/tests/fixtures/arguments.yaml
@@ -130,4 +130,4 @@ suites:
                 id: foo
                 args:
                   arg: 1
-                value: 1
\ No newline at end of file
+                value: 1
diff --git a/fluent-bundle/tests/resolver_fixtures.rs b/fluent-bundle/tests/resolver_fixtures.rs
index 2f02308..d7e1c14 100644
--- a/fluent-bundle/tests/resolver_fixtures.rs
+++ b/fluent-bundle/tests/resolver_fixtures.rs
@@ -135,14 +135,16 @@ fn create_bundle(
             let result = match f.as_str() {
                 "CONCAT" => bundle.add_function(f.as_str(), |args, _name_args| {
                     args.iter()
-                        .fold(String::new(), |acc, x| acc + &x.to_string())
+                        .fold(String::new(), |acc, x| {
+                            acc + &x.as_string::<FluentResource>(None)
+                        })
                         .into()
                 }),
                 "SUM" => bundle.add_function(f.as_str(), |args, _name_args| {
                     args.iter()
                         .fold(0.0, |acc, x| {
-                            if let FluentValue::Number(v) = x {
-                                acc + f64::from_str(v).expect("Failed to format a number")
+                            if let FluentValue::Number(v, _) = x {
+                                acc + v
                             } else {
                                 panic!("Type cannot be used in SUM");
                             }
@@ -285,7 +287,7 @@ fn test_test(test: &Test, defaults: &Option<TestDefaults>, mut scope: Scope) {
                     args.iter()
                         .map(|(k, v)| {
                             let val = match f64::from_str(v) {
-                                Ok(_) => FluentValue::Number(v.into()),
+                                Ok(_) => FluentValue::into_number(v),
                                 Err(_) => FluentValue::String(v.into()),
                             };
                             (k.as_str(), val)
diff --git a/fluent-bundle/tests/types_test.rs b/fluent-bundle/tests/types_test.rs
index 9055fee..bf13c06 100644
--- a/fluent-bundle/tests/types_test.rs
+++ b/fluent-bundle/tests/types_test.rs
@@ -23,9 +23,9 @@ fn fluent_value_matches() {
     let string_val_copy = FluentValue::String("string1".into());
     let string_val2 = FluentValue::String("23.5".into());
 
-    let number_val = FluentValue::Number("-23.5".into());
-    let number_val_copy = FluentValue::Number("-23.5".into());
-    let number_val2 = FluentValue::Number("23.5".into());
+    let number_val = FluentValue::into_number("-23.5");
+    let number_val_copy = FluentValue::into_number("-23.5");
+    let number_val2 = FluentValue::into_number("23.5");
 
     assert_eq!(string_val.matches(&string_val_copy, &scope), true);
     assert_eq!(string_val.matches(&string_val2, &scope), false);
@@ -44,12 +44,12 @@ fn fluent_value_matches() {
     let string_cat_many = FluentValue::String("many".into());
     let string_cat_other = FluentValue::String("other".into());
 
-    let number_cat_zero = FluentValue::Number("0".into());
-    let number_cat_one = FluentValue::Number("1".into());
-    let number_cat_two = FluentValue::Number("2".into());
-    let number_cat_few = FluentValue::Number("3".into());
-    let number_cat_many = FluentValue::Number("11".into());
-    let number_cat_other = FluentValue::Number("101".into());
+    let number_cat_zero = FluentValue::into_number("0");
+    let number_cat_one = FluentValue::into_number("1");
+    let number_cat_two = FluentValue::into_number("2");
+    let number_cat_few = FluentValue::into_number("3");
+    let number_cat_many = FluentValue::into_number("11");
+    let number_cat_other = FluentValue::into_number("101");
 
     assert_eq!(string_cat_zero.matches(&number_cat_zero, &scope), true);
     assert_eq!(string_cat_one.matches(&number_cat_one, &scope), true);
@@ -72,8 +72,8 @@ fn fluent_value_from() {
     assert_eq!(value_str, FluentValue::String("my str".into()));
     assert_eq!(value_string, FluentValue::String("my string".into()));
 
-    assert_eq!(value_f64, FluentValue::Number("23.5".into()));
-    assert_eq!(value_isize, FluentValue::Number("-23".into()));
+    assert_eq!(value_f64, FluentValue::into_number("23.5"));
+    assert_eq!(value_isize, FluentValue::into_number("-23"));
 }
 
 #[test]
@@ -114,3 +114,97 @@ fn fluent_custom_type() {
     assert_eq!(dt == dt3, false);
     assert_eq!(dt == sv, false);
 }
+
+#[test]
+fn fluent_custom_type_format() {
+    #[derive(Debug, PartialEq)]
+    struct DateTime {
+        epoch: usize,
+    };
+
+    impl DateTime {
+        pub fn new(epoch: usize) -> Self {
+            Self { epoch }
+        }
+    }
+
+    impl FluentType for DateTime {
+        fn duplicate(&self) -> Box<dyn FluentType> {
+            Box::new(DateTime { epoch: self.epoch })
+        }
+        fn as_string(&self) -> std::borrow::Cow<'static, str> {
+            format!("{}", self.epoch).into()
+        }
+    }
+
+    impl std::fmt::Display for DateTime {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            write!(f, "{}", self.epoch)
+        }
+    }
+
+    fn custom_formatter(num: &FluentValue) -> Option<String> {
+        match num {
+            FluentValue::Number(n, mfd) => {
+                Some(format!("{}.{}", n, "0".repeat(mfd.unwrap_or(2))).into())
+            }
+            _ => None,
+        }
+    }
+
+    let res = FluentResource::try_new(
+        r#"
+key-num-implicit = Hello { 5.000 } World
+key-num-explicit = Hello { NUMBER(5, minimumFractionDigits: 2) } World
+key-date-explicit = Hello { DATETIME(1579655307785) } World
+    "#
+        .into(),
+    )
+    .unwrap();
+    let mut bundle = FluentBundle::default();
+    bundle.add_resource(res).unwrap();
+    bundle.set_use_isolating(false);
+
+    bundle.set_formatter(Some(custom_formatter));
+
+    bundle
+        .add_function("NUMBER", |positional, named| match positional {
+            [FluentValue::Number(n, mfd)] => {
+                let mfd = if let Some(mfd) = named.get("minimumFractionDigits") {
+                    if let FluentValue::Number(v, _) = mfd {
+                        Some(*v as usize)
+                    } else {
+                        None
+                    }
+                } else {
+                    mfd.clone()
+                };
+                FluentValue::Number(n.clone(), mfd)
+            }
+            _ => FluentValue::None,
+        })
+        .unwrap();
+
+    bundle
+        .add_function("DATETIME", |positional, named| match positional {
+            [FluentValue::Number(n, _)] => {
+                FluentValue::Custom(Box::new(DateTime::new(*n as usize)))
+            }
+            _ => FluentValue::None,
+        })
+        .unwrap();
+
+    let mut errors = vec![];
+
+    let msg = bundle.get_message("key-num-explicit").unwrap();
+    let val = bundle.format_pattern(msg.value.unwrap(), None, &mut errors);
+    assert_eq!(val, "Hello 5.00 World");
+
+    let msg = bundle.get_message("key-num-implicit").unwrap();
+    let val = bundle.format_pattern(msg.value.unwrap(), None, &mut errors);
+    assert_eq!(val, "Hello 5.000 World");
+
+    let msg = bundle.get_message("key-date-explicit").unwrap();
+    let val = bundle.format_pattern(msg.value.unwrap(), None, &mut errors);
+    assert_eq!(val, "Hello 2020-01-28 World");
+}
